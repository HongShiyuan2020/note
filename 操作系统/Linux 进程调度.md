## 调度器

### 设计准测

- **公平：** 保证每个进程得到合理的CPU时间。
- **高效：** 使CPU保持忙碌状态，即总是有进程在CPU上运行。
- **响应时间：** 使交互用户的响应时间尽可能短。
- **周转时间：** 使批处理用户等待输出的时间尽可能短。
- **吞吐量：** 使单位时间内处理的进程数量尽可能多。
- **负载均衡：** 在多核多处理器系统中提供更高的性能。

### 进程

- **实时进程：**  对系统的响应时间要求很高，它们需要短的响应时间，并且这个时间的变化非常小，典型的实时进程有音乐播放器，视频播放器等。
- **普通进程：**  包括交互进程和非交互进程，交互进程如文本编辑器，它会不断的休眠，又不断地通过鼠标键盘进行唤醒，而非交互进程就如后台维护进程，他们对IO，响应时间没有很高的要求，比如编译器。

它们在linux内核运行时是共存的，**实时进程的优先级为0~99，实时进程优先级不会在运行期间改变(静态优先级)，而普通进程的优先级为100~139，普通进程的优先级会在内核运行期间进行相应的改变(动态优先级)**。 

### 调度策略

在linux系统中，调度策略分为  

- **SCHED_NORMAL：** 普通进程使用的调度策略，现在此调度策略使用的是CFS调度器。
- **SCHED_FIFO：** 实时进程使用的调度策略，此调度策略的进程一旦使用CPU则一直运行，直到有比其更高优先级的实时进程进入队列，或者其自动放弃CPU，适用于时间性要求比较高，但每次运行时间比较短的进程。
- **SCHED_RR：** 实时进程使用的时间片轮转法策略，实时进程的时间片用完后，调度器将其放到队列末尾，这样每个实时进程都可以执行一段时间。适用于每次运行时间比较长的实时进程。

### 调度时机

- 调用cond_resched()时
- 显式调用schedule()时
- 从系统调用或者异常中断返回用户空间时
- 从中断上下文返回用户空间时

当开启**内核抢占(默认开启)**时，会多出几个调度时机，如下  

- 在系统调用或者异常中断上下文中调用preempt_enable()时(多次调用preempt_enable()时，系统只会在最后一次调用时会调度)
- 在中断上下文中，从中断处理函数返回到可抢占的上下文时(这里是中断下半部，中断上半部实际上会关中断，而新的中断只会被登记，由于上半部处理很快，上半部处理完成后才会执行新的中断信号，这样就形成了中断可重入, 但是即使是中断下半部, 也是不能够被调度的)

## 涉及的数据结构

### 双向链表

```c
struct list_head { 
	struct list_head *next, *prev; 
};
```

### Hash表

```c

struct hlist_head { 
	struct hlist_node *first;
}; 

struct hlist_node { 
	struct hlist_node *next;
	struct hlist_node **pprev;
};
```

### 红黑树

```c
//红黑树节点 
struct rb_node { 
	unsigned long __rb_parent_color; 
	struct rb_node *rb_right; 
	struct rb_node *rb_left; 
} __attribute__((aligned(sizeof(long)))); 

//红黑树根节点 
struct rb_root { 
	struct rb_node *rb_node; 
};
```

![[Pasted image 20241202192713.png]]![[Pasted image 20241202193039.png]]

## 组调度

